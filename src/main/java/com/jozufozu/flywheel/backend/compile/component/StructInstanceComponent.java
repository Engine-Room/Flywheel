package com.jozufozu.flywheel.backend.compile.component;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;

import com.jozufozu.flywheel.Flywheel;
import com.jozufozu.flywheel.api.instance.InstanceType;
import com.jozufozu.flywheel.api.layout.FloatRepr;
import com.jozufozu.flywheel.api.layout.IntegerRepr;
import com.jozufozu.flywheel.api.layout.Layout;
import com.jozufozu.flywheel.api.layout.MatrixElementType;
import com.jozufozu.flywheel.api.layout.ScalarElementType;
import com.jozufozu.flywheel.api.layout.UnsignedIntegerRepr;
import com.jozufozu.flywheel.api.layout.VectorElementType;
import com.jozufozu.flywheel.backend.compile.Pipeline;
import com.jozufozu.flywheel.backend.glsl.generate.FnSignature;
import com.jozufozu.flywheel.backend.glsl.generate.GlslBlock;
import com.jozufozu.flywheel.backend.glsl.generate.GlslBuilder;
import com.jozufozu.flywheel.backend.glsl.generate.GlslExpr;
import com.jozufozu.flywheel.backend.glsl.generate.GlslStruct;

// TODO: Use a uvec4[] instead of a FlwPackedInstance[] in the SSBO to store data and reuse unpacking code from BufferTextureInstanceComponent.
// Unpacking should be moved from BufferTextureInstanceComponent to InstanceAssemblerComponent and this class should be renamed to SsboInstanceComponent. Further abstraction may be possible.
// Currently, some of the unpacking code generated by this class is incorrect. It is correct in BufferTextureInstanceComponent.
public class StructInstanceComponent extends InstanceAssemblerComponent {
	private static final String UNPACK_ARG = "p";
	private static final GlslExpr.Variable UNPACKING_VARIABLE = GlslExpr.variable(UNPACK_ARG);
	private static final String PACKED_STRUCT_NAME = "FlwPackedInstance";

	public StructInstanceComponent(InstanceType<?> type) {
		super(type);
	}

	public static StructInstanceComponent create(InstanceType<?> type) {
		return new StructInstanceComponent(type);
	}

	public static StructInstanceComponent create(Pipeline.InstanceAssemblerContext ctx) {
		return create(ctx.instanceType());
	}

	@Override
	public String name() {
		return Flywheel.rl("struct_instance_assembler").toString();
	}

	@Override
	protected void generateUnpacking(GlslBuilder builder) {
		var packed = builder.struct();
		packed.setName(PACKED_STRUCT_NAME);

		var unpackArgs = new ArrayList<GlslExpr>();

		for (Layout.Element element : layout.elements()) {
			unpackArgs.add(unpackElement(element, packed));
		}

		var block = new GlslBlock();
		block.ret(GlslExpr.call(STRUCT_NAME, unpackArgs));

		builder.blankLine();
		builder.function()
				.signature(FnSignature.create()
						.returnType(STRUCT_NAME)
						.name(UNPACK_FN_NAME)
						.arg(PACKED_STRUCT_NAME, UNPACK_ARG)
						.build())
				.body(block);
	}

	private static GlslExpr unpackElement(Layout.Element element, GlslStruct packed) {
		// FIXME: I don't think we're unpacking signed byte/short values correctly
		// FIXME: we definitely don't consider endianness. this all assumes little endian which works on my machine.
		var type = element.type();
		var name = element.name();

		if (type instanceof ScalarElementType scalar) {
			return unpackScalar(scalar, name, packed);
		} else if (type instanceof VectorElementType vector) {
			return unpackVector(vector, name, packed);
		} else if (type instanceof MatrixElementType matrix) {
			return unpackMatrix(matrix, name, packed);
		}

		throw new IllegalArgumentException("Unknown type " + type);
	}

	private static GlslExpr unpackScalar(ScalarElementType type, String fieldName, GlslStruct packed) {
		var repr = type.repr();

		if (repr instanceof IntegerRepr intRepr) {
			return unpackIntScalar(intRepr, fieldName, packed);
		} else if (repr instanceof UnsignedIntegerRepr uintRepr) {
			return unpackUintScalar(uintRepr, fieldName, packed);
		} else if (repr instanceof FloatRepr floatRepr) {
			return unpackFloatScalar(floatRepr, fieldName, packed);
		}

		throw new IllegalArgumentException("Unknown repr " + repr);
	}

	private static GlslExpr unpackIntScalar(IntegerRepr repr, String fieldName, GlslStruct packed) {
		return switch (repr) {
			case BYTE -> unpackScalar("uint", fieldName, packed, e -> e.and(0xFF)
					.cast("int"));
			case SHORT -> unpackScalar("uint", fieldName, packed, e -> e.and(0xFFFF)
					.cast("int"));
			case INT -> unpackScalar("int", fieldName, packed);
		};
	}

	private static GlslExpr unpackUintScalar(UnsignedIntegerRepr repr, String fieldName, GlslStruct packed) {
		return switch (repr) {
			case UNSIGNED_BYTE -> unpackScalar("uint", fieldName, packed, e -> e.and(0xFF));
			case UNSIGNED_SHORT -> unpackScalar("uint", fieldName, packed, e -> e.and(0xFFFF));
			case UNSIGNED_INT -> unpackScalar("uint", fieldName, packed);
		};
	}

	private static GlslExpr unpackFloatScalar(FloatRepr repr, String fieldName, GlslStruct packed) {
		return switch (repr) {
			case BYTE -> unpackScalar("uint", fieldName, packed, e -> e.and(0xFF)
					.cast("int")
					.cast("float"));
			case NORMALIZED_BYTE -> unpackScalar("uint", fieldName, packed, e -> e.callFunction("unpackSnorm4x8")
					.swizzle("x"));
			case UNSIGNED_BYTE -> unpackScalar("uint", fieldName, packed, e -> e.and(0xFF)
					.cast("float"));
			case NORMALIZED_UNSIGNED_BYTE ->
					unpackScalar("uint", fieldName, packed, e -> e.callFunction("unpackUnorm4x8")
							.swizzle("x"));
			case SHORT -> unpackScalar("uint", fieldName, packed, e -> e.and(0xFFFF)
					.cast("int")
					.cast("float"));
			case NORMALIZED_SHORT -> unpackScalar("uint", fieldName, packed, e -> e.callFunction("unpackSnorm2x16")
					.swizzle("x"));
			case UNSIGNED_SHORT -> unpackScalar("uint", fieldName, packed, e -> e.and(0xFFFF)
					.cast("float"));
			case NORMALIZED_UNSIGNED_SHORT ->
					unpackScalar("uint", fieldName, packed, e -> e.callFunction("unpackUnorm2x16")
							.swizzle("x"));
			case INT -> unpackScalar("int", fieldName, packed, e -> e.cast("float"));
			case NORMALIZED_INT -> unpackScalar("int", fieldName, packed, e -> e.div(2147483647f)
					.clamp(-1, 1));
			case UNSIGNED_INT -> unpackScalar("uint", fieldName, packed, e -> e.cast("float"));
			case NORMALIZED_UNSIGNED_INT -> unpackScalar("uint", fieldName, packed, e -> e.div(4294967295f));
			case FLOAT -> unpackScalar("float", fieldName, packed);
		};
	}

	private static GlslExpr unpackScalar(String packedType, String fieldName, GlslStruct packed) {
		return unpackScalar(packedType, fieldName, packed, Function.identity());
	}

	private static GlslExpr unpackScalar(String packedType, String fieldName, GlslStruct packed, Function<GlslExpr, GlslExpr> perElement) {
		packed.addField(packedType, fieldName);
		return perElement.apply(UNPACKING_VARIABLE.access(fieldName));
	}

	private static GlslExpr unpackVector(VectorElementType type, String fieldName, GlslStruct packed) {
		var repr = type.repr();
		int size = type.size();

		if (repr instanceof IntegerRepr intRepr) {
			return unpackIntVector(intRepr, size, fieldName, packed);
		} else if (repr instanceof UnsignedIntegerRepr uintRepr) {
			return unpackUintVector(uintRepr, size, fieldName, packed);
		} else if (repr instanceof FloatRepr floatRepr) {
			return unpackFloatVector(floatRepr, size, fieldName, packed);
		}

		throw new IllegalArgumentException("Unknown repr " + repr);
	}

	private static GlslExpr unpackIntVector(IntegerRepr repr, int size, String fieldName, GlslStruct packed) {
		return switch (repr) {
			case BYTE -> unpackByteBackedVector("ivec" + size, size, fieldName, packed, e -> e.cast("int"));
			case SHORT -> unpackShortBackedVector("ivec" + size, size, fieldName, packed, e -> e.cast("int"));
			case INT -> unpackVector("ivec" + size, size, "int", fieldName, packed);
		};
	}

	private static GlslExpr unpackUintVector(UnsignedIntegerRepr repr, int size, String fieldName, GlslStruct packed) {
		return switch (repr) {
			case UNSIGNED_BYTE -> unpackByteBackedVector("uvec" + size, size, fieldName, packed, e -> e.cast("uint"));
			case UNSIGNED_SHORT -> unpackShortBackedVector("uvec" + size, size, fieldName, packed, e -> e.cast("uint"));
			case UNSIGNED_INT -> unpackVector("uvec" + size, size, "uint", fieldName, packed);
		};
	}

	private static GlslExpr unpackFloatVector(FloatRepr repr, int size, String fieldName, GlslStruct packed) {
		return switch (repr) {
			case BYTE -> unpackByteBackedVector("vec" + size, size, fieldName, packed, e -> e.cast("int")
					.cast("float"));
			case NORMALIZED_BYTE -> unpackByteBuiltinVector(size, fieldName, packed, "unpackSnorm4x8");
			case UNSIGNED_BYTE -> unpackByteBackedVector("vec" + size, size, fieldName, packed, e -> e.cast("float"));
			case NORMALIZED_UNSIGNED_BYTE -> unpackByteBuiltinVector(size, fieldName, packed, "unpackUnorm4x8");
			case SHORT -> unpackShortBackedVector("vec" + size, size, fieldName, packed, e -> e.cast("int")
					.cast("float"));
			case NORMALIZED_SHORT -> unpackShortBuiltinVector(size, fieldName, packed, "unpackSnorm2x16");
			case UNSIGNED_SHORT -> unpackShortBackedVector("vec" + size, size, fieldName, packed, e -> e.cast("float"));
			case NORMALIZED_UNSIGNED_SHORT -> unpackShortBuiltinVector(size, fieldName, packed, "unpackUnorm2x16");
			case INT -> unpackVector("vec" + size, size, "int", fieldName, packed, e -> e.cast("float"));
			case NORMALIZED_INT -> unpackVector("vec" + size, size, "int", fieldName, packed, e -> e.div(2147483647f)
					.clamp(-1, 1));
			case UNSIGNED_INT -> unpackVector("vec" + size, size, "float", fieldName, packed, e -> e.cast("float"));
			case NORMALIZED_UNSIGNED_INT ->
					unpackVector("vec" + size, size, "uint", fieldName, packed, e -> e.div(4294967295f));
			case FLOAT -> unpackVector("vec" + size, size, "float", fieldName, packed);
		};
	}

	private static GlslExpr unpackByteBackedVector(String outType, int size, String fieldName, GlslStruct packed, Function<GlslExpr, GlslExpr> perElement) {
		packed.addField("uint", fieldName);
		List<GlslExpr> args = new ArrayList<>();
		for (int i = 0; i < size; i++) {
			int bitPos = i * 8;
			var element = UNPACKING_VARIABLE.access(fieldName)
					.rsh(bitPos)
					.and(0xFF);
			args.add(perElement.apply(element));
		}
		return GlslExpr.call(outType, args);
	}

	private static GlslExpr unpackShortBackedVector(String outType, int size, String fieldName, GlslStruct packed, Function<GlslExpr, GlslExpr> perElement) {
		List<GlslExpr> args = new ArrayList<>();
		for (int i = 0; i < size; i++) {
			int unpackField = i / 2;
			int bitPos = (i % 2) * 16;
			var name = fieldName + "_" + unpackField;
			if (bitPos == 0) {
				// First time we're seeing this field, add it to the struct.
				packed.addField("uint", name);
			}
			var element = UNPACKING_VARIABLE.access(name)
					.rsh(bitPos)
					.and(0xFFFF);
			args.add(perElement.apply(element));
		}
		return GlslExpr.call(outType, args);
	}

	private static GlslExpr unpackByteBuiltinVector(int size, String fieldName, GlslStruct packed, String func) {
		packed.addField("uint", fieldName);
		GlslExpr expr = UNPACKING_VARIABLE.access(fieldName)
				.callFunction(func);
		return switch (size) {
			case 2 -> expr.swizzle("xy");
			case 3 -> expr.swizzle("xyz");
			case 4 -> expr;
			default -> throw new IllegalArgumentException("Invalid vector size " + size);
		};
	}

	private static GlslExpr unpackShortBuiltinVector(int size, String fieldName, GlslStruct packed, String func) {
		if (size == 2) {
			packed.addField("uint", fieldName);
			return UNPACKING_VARIABLE.access(fieldName)
					.callFunction(func);
		} else {
			var name0 = fieldName + "_" + 0;
			var name1 = fieldName + "_" + 1;
			packed.addField("uint", name0);
			packed.addField("uint", name1);
			GlslExpr xy = UNPACKING_VARIABLE.access(name0)
					.callFunction(func);

			GlslExpr zw = UNPACKING_VARIABLE.access(name1)
					.callFunction(func);

			if (size == 3) {
				return GlslExpr.call("vec3", List.of(xy.swizzle("xy"), zw.swizzle("x")));
			} else {
				return GlslExpr.call("vec4", List.of(xy, zw));
			}
		}
	}

	private static GlslExpr unpackVector(String outType, int size, String backingType, String fieldName, GlslStruct packed) {
		return unpackVector(outType, size, backingType, fieldName, packed, Function.identity());
	}

	private static GlslExpr unpackVector(String outType, int size, String backingType, String fieldName, GlslStruct packed, Function<GlslExpr, GlslExpr> perElement) {
		List<GlslExpr> args = new ArrayList<>();
		for (int i = 0; i < size; i++) {
			var name = fieldName + "_" + i;
			packed.addField(backingType, name);
			args.add(perElement.apply(UNPACKING_VARIABLE.access(name)));
		}
		return GlslExpr.call(outType, args);
	}

	private static GlslExpr unpackMatrix(MatrixElementType type, String name, GlslStruct packed) {
		var repr = type.repr();
		int rows = type.rows();
		int columns = type.columns();

		List<GlslExpr> args = new ArrayList<>();

		for (int i = 0; i < columns; i++) {
			args.add(unpackFloatVector(repr, rows, name + "_" + i, packed));
		}

		return GlslExpr.call("mat" + columns + "x" + rows, args);
	}
}
