plugins {
    id 'idea'
    // make sure gradle loads the same arch plugin across all subprojects
    id 'dev.architectury.loom' apply false
}

println("Java: ${System.getProperty('java.version')}, JVM: ${System.getProperty('java.vm.version')} (${System.getProperty('java.vendor')}), Arch: ${System.getProperty('os.arch')}")

allprojects {
    // Need to setup the java plugin for all projects so that our subprojects can find an output directory
    apply plugin: 'java'
    apply plugin: 'maven-publish'

    boolean dev = System.getenv('RELEASE') == null || System.getenv('RELEASE').equalsIgnoreCase('false')
    String buildNumber = System.getenv('BUILD_NUMBER')

    group = 'com.jozufozu.flywheel'
    version = mod_version + (dev && buildNumber != null ? "-${buildNumber}" : '')

    base {
        archivesName = "flywheel-${name}-${artifact_minecraft_version}"
    }

    java {
        JavaVersion javaVersion = JavaVersion.toVersion(java_version)
        sourceCompatibility = javaVersion
        targetCompatibility = javaVersion

        toolchain.languageVersion = JavaLanguageVersion.of(java_version)

        withSourcesJar()
        withJavadocJar()
    }

    // make builds reproducible
    tasks.withType(AbstractArchiveTask).configureEach {
        preserveFileTimestamps = false
        reproducibleFileOrder = true
    }

    // module metadata is often broken on multi-platform projects
    tasks.withType(GenerateModuleMetadata).configureEach {
        enabled = false
    }

    tasks.withType(JavaCompile).configureEach { JavaCompile javaCompile ->
        javaCompile.options.encoding = 'UTF-8'
        javaCompile.options.release = Integer.parseInt(java_version)
        javaCompile.options.compilerArgs = ['-Xdiags:verbose']
    }

    tasks.named('jar', Jar).configure { Jar jar ->
        archiveClassifier = ''
        addLicense(jar)
    }

    tasks.named('sourcesJar', Jar).configure { Jar jar ->
        addLicense(jar)
    }

    tasks.named('javadoc', Javadoc).configure { Javadoc javadoc ->
        javadoc.source sourceSets.main.allJava
        // prevent java 8's strict doclint for javadocs from failing builds
        javadoc.options.addStringOption('Xdoclint:none', '-quiet')
    }
}

subprojects {
    apply plugin: 'dev.architectury.loom'

    loom {
        silentMojangMappingsLicense()
    }

    repositories {
        mavenCentral()
        maven {
            name = 'ParchmentMC'
            url = 'https://maven.parchmentmc.org'
        }
        maven {
            name 'tterrag maven'
            url 'https://maven.tterrag.com/'
        }
        maven {
            url 'https://www.cursemaven.com'
            content {
                includeGroup "curse.maven"
            }
        }
        maven {
            name = "Modrinth"
            url = "https://api.modrinth.com/maven"
            content {
                includeGroup "maven.modrinth"
            }
        }
    }

    dependencies {
        minecraft "com.mojang:minecraft:${minecraft_version}"
        mappings(loom.layered() {
            officialMojangMappings()
            parchment("org.parchmentmc.data:parchment-${minecraft_version}:${parchment_version}@zip")
        })

        api 'com.google.code.findbugs:jsr305:3.0.2'
    }

    processResources {
        var replaceProperties = [
                mod_id                        : mod_id,
                mod_name                      : mod_name,
                mod_description               : mod_description,
                mod_license                   : mod_license,
                mod_sources                   : mod_sources,
                mod_issues                    : mod_issues,
                mod_homepage                  : mod_homepage,
                mod_version                   : mod_version,
                minecraft_semver_version_range: minecraft_semver_version_range,
                minecraft_maven_version_range : minecraft_maven_version_range,
                fabric_api_version_range      : fabric_api_version_range,
                forge_version_range           : forge_version_range,
        ]
        inputs.properties replaceProperties

        filesMatching(['pack.mcmeta', 'fabric.mod.json', 'META-INF/mods.toml']) {
            expand replaceProperties
        }
    }

    publishing {
        repositories {
            maven {
                url "file://${rootProject.projectDir}/mcmodsrepo"
            }

            if (project.hasProperty('mavendir')) {
                maven { url rootProject.file(property('mavendir')) }
            }
        }
    }

    apply from: rootProject.file('gradle/package-infos.gradle')

    ideaSyncTask.finalizedBy(generatePackageInfos)
}

// Common configuration for platform dependent subprojects.
for (final String subprojectName in [':fabric', ':forge']) {
    project(subprojectName) {
        evaluationDependsOn(':common')

        loom {
            runs {
                client {
                    ideConfigGenerated true

                    // Turn on our own debug flags
                    property 'flw.dumpShaderSource', 'true'
                    property 'flw.debugMemorySafety', 'true'

                    // Turn on mixin debug flags
                    property 'mixin.debug.export', 'true'
                    property 'mixin.debug.verbose', 'true'

                    // 720p baby!
                    programArgs '--width', '1280', '--height', '720'
                }

                // We're a client mod, but we need to make sure we correctly render when playing on a server.
                server {
                    ideConfigGenerated true
                    programArgs '--nogui'
                }
            }
        }

        tasks.named('processResources', ProcessResources).configure { ProcessResources processResources ->
            processResources.from project(':common').tasks.named('processResources', ProcessResources).get().source
        }

        tasks.named('compileJava', JavaCompile).configure { JavaCompile compileJava ->
            compileJava.source project(':common').tasks.named('compileJava', JavaCompile).get().source
            excludeDuplicatePackageInfos(compileJava)
        }

        tasks.named('javadoc', Javadoc).configure { Javadoc javadoc ->
            javadoc.source project(':common').tasks.named('javadoc', Javadoc).get().source
            excludeDuplicatePackageInfos(javadoc)
        }

        tasks.named('jar', Jar).configure { Jar jar ->
            excludeDuplicatePackageInfos(jar)
        }

        tasks.named('sourcesJar', Jar).configure { Jar jar ->
            def commonSources = project(':common').tasks.named('sourcesJar', Jar)
            dependsOn commonSources
            jar.from zipTree(commonSources.flatMap { it.archiveFile })

            excludeDuplicatePackageInfos(jar)
        }
    }
}

static void addLicense(Jar jarTask) {
    jarTask.from('LICENSE.md') {
        rename '(.*)\\.(.*)', '$1_' + jarTask.archiveBaseName + '.$2'
    }
}

// We have duplicate packages between the common and platform dependent subprojects.
// In theory the package-info.java files should be identical, so just take the first one we find.
static void excludeDuplicatePackageInfos(AbstractCopyTask copyTask) {
    copyTask.filesMatching('**/package-info.java') {
        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    }
}

// The compile/javadoc tasks have a different base type that isn't so smart about exclusion handling.
static void excludeDuplicatePackageInfos(SourceTask sourceTask) {
    // FIXME: actually scan the files and exclude the duplicates
    //  may be tough because the files have absolute paths
    sourceTask.exclude('**/package-info.java')
}

idea {
    // Tell IDEA to always download sources/javadoc artifacts from maven.
    module {
        downloadJavadoc = true
        downloadSources = true
    }
}
