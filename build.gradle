plugins {
    id 'eclipse'
    id 'idea'
    // make sure gradle loads the same arch plugin across all subprojects
    id 'dev.architectury.loom' apply false
}

println "Java: ${System.getProperty 'java.version'}, JVM: ${System.getProperty 'java.vm.version'} (${System.getProperty 'java.vendor'}), Arch: ${System.getProperty 'os.arch'}"

subprojects {
    apply plugin: "dev.architectury.loom"

    base {
        archivesName = "flywheel-${name}-${artifact_minecraft_version}"
    }

    boolean dev = System.getenv('RELEASE') == null || System.getenv('RELEASE').equalsIgnoreCase('false');

    ext.buildNumber = System.getenv('BUILD_NUMBER')

    group = 'com.jozufozu.flywheel'
    version = mod_version + (dev && buildNumber != null ? "-${buildNumber}" : '')

    loom {
        silentMojangMappingsLicense()
    }

    repositories {
        maven {
            name = 'ParchmentMC'
            url = 'https://maven.parchmentmc.org'
        }
        maven {
            url 'https://www.cursemaven.com'
            content {
                includeGroup "curse.maven"
            }
        }
        maven {
            name 'tterrag maven'
            url 'https://maven.tterrag.com/'
        }
        maven {
            name = "Modrinth"
            url = "https://api.modrinth.com/maven"
            content {
                includeGroup "maven.modrinth"
            }
        }
        mavenCentral()
    }

    dependencies {
        minecraft "com.mojang:minecraft:$minecraft_version"
        mappings(loom.layered() {
            officialMojangMappings()
            parchment("org.parchmentmc.data:parchment-${minecraft_version}:${parchment_version}@zip")
        })

        implementation "com.google.code.findbugs:jsr305:3.0.2"
    }

    processResources {
        var replaceProperties = [
                minecraft_version      : minecraft_version,
                minecraft_version_range: minecraft_version_range,
                forge_version          : forge_version,
                forge_version_range    : forge_version_range,
                loader_version_range   : loader_version_range,
                mod_version            : mod_version,
                mod_id                 : mod_id,
                mod_name               : mod_name,
                mod_description        : mod_description,
                mod_license            : mod_license,
                mod_sources            : mod_sources,
                mod_issues             : mod_issues,
                mod_homepage           : mod_homepage,
        ]
        inputs.properties replaceProperties

        filesMatching(['pack.mcmeta', 'fabric.mod.json', 'META-INF/mods.toml', 'META-INF/neoforge.mods.toml']) {
            expand replaceProperties + [project: project]
        }
    }

    apply from: rootProject.file('gradle/package-infos.gradle')

    ideaSyncTask.finalizedBy(generatePackageInfos)
}

// Need to setup the java plugin for all projects so that our subprojects can find an output directory
allprojects {
    apply plugin: "java"
    apply plugin: "maven-publish"

    java {
        JavaVersion javaVersion = JavaVersion.toVersion(java_version)
        sourceCompatibility = javaVersion
        targetCompatibility = javaVersion

        toolchain.languageVersion = JavaLanguageVersion.of(java_version)

        withSourcesJar()
        withJavadocJar()
    }

    // make builds reproducible
    tasks.withType(AbstractArchiveTask).configureEach {
        preserveFileTimestamps = false
        reproducibleFileOrder = true
    }

    // module metadata is often broken on multi-platform projects
    tasks.withType(GenerateModuleMetadata).configureEach {
        enabled = false
    }

    tasks.withType(JavaCompile).configureEach { JavaCompile javaCompile ->
        javaCompile.options.encoding = 'UTF-8'
        javaCompile.options.release = Integer.parseInt(java_version)
        javaCompile.options.compilerArgs = ['-Xdiags:verbose']
    }

    tasks.named('jar', Jar).configure { Jar jar ->
        archiveClassifier = ''
        addManifest(jar)
        addLicense(jar)
    }

    tasks.named('sourcesJar', Jar).configure { Jar jar ->
        addManifest(jar)
        addLicense(jar)
    }

    tasks.named('javadoc', Javadoc).configure { Javadoc javadoc ->
        javadoc.source sourceSets.main.allJava
        // prevent java 8's strict doclint for javadocs from failing builds
        javadoc.options.addStringOption('Xdoclint:none', '-quiet')
    }
}

// Common configuration for platform dependent subprojects.
for (final def subprojectName in [":fabric", ":forge"]) {
    project(subprojectName) {
        evaluationDependsOn(':common')

        loom {
            runs {
                client {
                    ideConfigGenerated true
                    // Turn on our own debug flags
                    property 'flw.dumpShaderSource', 'true'
                    property 'flw.debugMemorySafety', 'true'

                    // Turn on mixin debug flags
                    property 'mixin.debug.export', 'true'
                    property 'mixin.debug.verbose', 'true'

                    // 720p baby!
                    programArgs '--width', '1280', '--height', '720'
                }

                // We're a client mod, but we need to make sure we correctly render when playing on a server.
                server {
                    ideConfigGenerated true
                    programArgs '--nogui'
                }
            }
        }

        tasks.named('processResources', ProcessResources).configure { ProcessResources processResources ->
            processResources.from project(':common').tasks.named('processResources', ProcessResources).get().source
        }

        tasks.named('compileJava', JavaCompile).configure { JavaCompile compileJava ->
            compileJava.source project(':common').tasks.named('compileJava', JavaCompile).get().source
            excludeDuplicatePackageInfos(compileJava)
        }

        tasks.named('javadoc', Javadoc).configure { Javadoc javadoc ->
            javadoc.source project(':common').tasks.named('javadoc', Javadoc).get().source
            excludeDuplicatePackageInfos(javadoc)
        }

        tasks.named('jar', Jar).configure { Jar jar ->
            excludeDuplicatePackageInfos(jar)
        }

        tasks.named('sourcesJar', Jar).configure { Jar jar ->
            def commonSources = project(":common").tasks.named('sourcesJar', Jar)
            dependsOn commonSources
            jar.from zipTree(commonSources.flatMap { it.archiveFile })

            excludeDuplicatePackageInfos(jar)
        }
    }
}

static void addLicense(Jar jarTask) {
    jarTask.from('LICENSE.md') {
        rename '(.*)\\.(.*)', '$1_' + jarTask.archiveBaseName + '.$2'
    }
}

static void addManifest(Jar jarTask) {
    jarTask.manifest {
        attributes([
                'Specification-Title'     : 'flywheel',
                // 'Specification-Vendor': 'flywheel authors',
                'Specification-Version'   : '1', // We are version 1 of ourselves
                'Implementation-Title'    : jarTask.archiveBaseName,
                'Implementation-Version'  : jarTask.archiveVersion,
                // 'Implementation-Vendor': 'flywheel authors',
                'Implementation-Timestamp': new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
        ])
    }
}

// We have duplicate packages between the common and platform dependent subprojects.
// In theory the package-info.java files should be identical, so just take the first one we find.
static void excludeDuplicatePackageInfos(AbstractCopyTask copyTask) {
    copyTask.filesMatching('**/package-info.java') {
        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    }
}

// The compile/javadoc tasks have a different base type that isn't so smart about exclusion handling.
static void excludeDuplicatePackageInfos(SourceTask sourceTask) {
    // FIXME: actually scan the files and exclude the duplicates
    //  may be tough because the files have absolute paths
    sourceTask.exclude('**/package-info.java')
}

idea {
    // Tell IDEA to always download sources/javadoc artifacts from maven.
    module {
        downloadJavadoc = true
        downloadSources = true
    }
}
