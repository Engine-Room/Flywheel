evaluationDependsOn(':common')

loom {
    runs {
        client {
            ideConfigGenerated true

            // Turn on our own debug flags
            property 'flw.dumpShaderSource', 'true'
            property 'flw.debugMemorySafety', 'true'

            // Turn on mixin debug flags
            property 'mixin.debug.export', 'true'
            property 'mixin.debug.verbose', 'true'

            // 720p baby!
            programArgs '--width', '1280', '--height', '720'
        }

        // We're a client mod, but we need to make sure we correctly render when playing on a server.
        server {
            ideConfigGenerated true
            programArgs '--nogui'
        }
    }
}

dependencies {
    compileOnly project(path: ':common', configuration: 'commonApi')
    compileOnly project(path: ':common', configuration: 'commonLib')
    compileOnly project(path: ':common', configuration: 'commonBackend')
    compileOnly project(path: ':common', configuration: 'commonImpl')
}

SourceSet commonApiSource = project(':common').sourceSets.api
SourceSet commonLibSource = project(':common').sourceSets.lib
SourceSet commonBackendSource = project(':common').sourceSets.backend
SourceSet commonMainSource = project(':common').sourceSets.main

def commonSources = [commonApiSource, commonLibSource, commonBackendSource, commonMainSource]

tasks.named('processResources', ProcessResources).configure { ProcessResources processResources ->
    // No resources in API
    processResources.from commonLibSource.resources
    processResources.from commonBackendSource.resources
    processResources.from commonMainSource.resources
}

tasks.named('compileJava', JavaCompile).configure { JavaCompile compileJava ->
    // TODO: Can we avoid this duplication? Would be nice to repackage the 4 common jars without having to re compile
    commonSources.forEach { compileJava.source it.allJava }

    excludeDuplicatePackageInfos(compileJava)
}

tasks.named('javadoc', Javadoc).configure { Javadoc javadoc ->
    commonSources.forEach { javadoc.source it.allJava }

    excludeDuplicatePackageInfos(javadoc)
}

tasks.named('jar', Jar).configure { Jar jar ->
    excludeDuplicatePackageInfos(jar)
}

tasks.named('sourcesJar', Jar).configure { Jar jar ->
    commonSources.forEach { jar.from it.allJava }

    excludeDuplicatePackageInfos(jar)
}

// We have duplicate packages between the common and platform dependent subprojects.
// In theory the package-info.java files should be identical, so just take the first one we find.
static void excludeDuplicatePackageInfos(AbstractCopyTask copyTask) {
    copyTask.filesMatching('**/package-info.java') {
        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    }
}

// The compile/javadoc tasks have a different base type that isn't so smart about exclusion handling.
static void excludeDuplicatePackageInfos(SourceTask sourceTask) {
    // FIXME: actually scan the files and exclude the duplicates
    //  may be tough because the files have absolute paths
    sourceTask.exclude('**/package-info.java')
}
